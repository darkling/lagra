#!/usr/bin/escript
%%! -pa deps/jsx/ebin

%% This script is written in erlang, to read the manifest for the
%% JSON-LD tests as plain JSON, because it's not actually compliant
%% JSON-LD (the "expect" field is declared as @id in the context, but
%% can also contain string data).

-define(HEADER, "%%% The following module is generated by the gen-jsonld-test-suite script.
%%% Do not edit by hand.

-module(jsonld_w3_SUITE).
-include_lib(\"common_test/include/ct.hrl\").
-export([all/0]).

%% The test suite is generated from the test manifest file 
%% ct/jsonld_w3_SUITE_data/manifest.jsonld

").

-define(INIT_END, "init_per_suite(Config) ->
    {ok, _} = application:ensure_all_started(lagra),
    [{prefix, \"${base}\"}|Config].
~nend_per_suite(_Config) ->
    application:stop(lagra),
    ok.
~ninit_per_testcase(_, Config) ->
    Store1 = lagra:create_store(trivial),
    Store2 = lagra:create_store(trivial),
    [{store1, Store1}, {store2, Store2}|Config].
~nend_per_testcase(_, Config) ->
    Store1 = ?config(store1, Config),
    Store2 = ?config(store2, Config),
    lagra:destroy_store(Store1),
	lagra:destroy_store(Store2).

").

main([ManifestFile]) ->
	Where = filename:dirname(ManifestFile),
	{ok, JsonManifest} = file:read_file(ManifestFile),
	Manifest = jsx:decode(JsonManifest, [{return_maps, true}]),
	Pieces = lists:append([process_manifest(Where, SubMf)
						   || SubMf <- maps:get(<<"sequence">>, Manifest)]),
	io:format(?HEADER, []),
    [io:format("-export([~ts/1]).~n", [FnName]) || {FnName, _} <- Pieces,
												   FnName =/= ""],
    io:format("-export([init_per_suite/1, end_per_suite/1]).~n", []),
	io:format("-export([init_per_testcase/2, end_per_testcase/2]).~n~n", []),
	io:format(?INIT_END, []),
	[io:format("~ts~n~n", [FnBody]) || {FnName, FnBody} <- Pieces,
									   FnName =/= ""],
	io:format("all() ->~n    [~ts].~n",
			  [lists:join(",", [FnName || {FnName, _} <- Pieces,
										  FnName =/= ""])]).

process_manifest(Dir, Filename) ->
	{ok, JsonMf} = file:read_file(filename:join(Dir, Filename)),
	Manifest = jsx:decode(JsonMf, [return_maps]),
	[process_test(test_type(TestDef), TestDef)
	 || TestDef <- maps:get(<<"sequence">>, Manifest)].

test_type(#{<<"@type">> := Types}) ->
	lists:sort(Types).

process_test([<<"jld:FromRDFTest">>, <<"jld:PositiveEvaluationTest">>],
			 TestDef) ->
	#{<<"@id">> := TestId,
	  <<"input">> := InputFile,
	  <<"expect">> := ExpectFile} = TestDef,
	Options = maps:get(<<"option">>, TestDef, #{}),
	MO1 = case Options of
			  #{<<"useNativeTypes">> := NativeTypes} ->
				  #{native_types => NativeTypes};
			  _ -> #{}
		  end,
	MO2 = case Options of
			  #{<<"useRdfType">> := RdfType} ->
				  MO1#{rdf_type => RdfType};
			  _ -> MO1
		  end,

	FnName = ["'", "fromRDF", TestId, "'"],
	FnBody =
		[FnName, "(Config) ->
    Store = ?config(store1, Config),
    Filename = filename:join(?config(data_dir, Config), \"", InputFile, "\"),
    io:format(\"Filename = ~p~n\", [Filename]),
    {ok, InFile} = file:open(Filename, [read, {encoding, utf8}, binary]),
    ok = lagra:parse(Store, InFile, nquads),
    ok = file:close(InFile),
    Output = lagra:serialize(Store, mem, jsonld, ",
		 io_lib:format("~p", [MO2]), "),
    ExpectFile = filename:join(?config(data_dir, Config), \"", ExpectFile, "\"),
    {ok, ExpData} = file:read_file(ExpectFile),
    Expected = jsx:decode(ExpData, [return_maps]),
    io:format(\"Generated ~p~n\", [Output]),
    io:format(\"Expected ~p~n\", [Expected]),
    true = lagra_jsonld_utils:jsonld_object_compare(Output, Expected)."
		],

	case maps:get(<<"specVersion">>, Options, <<"json-ld-1.0">>) of
		<<"json-ld-1.0">> ->
			{FnName, FnBody};
		<<"json-ld-1.1">> ->
			{[], []};
		_ ->
			{FnName, FnBody}
	end;

process_test(_, _) ->
	skip.
